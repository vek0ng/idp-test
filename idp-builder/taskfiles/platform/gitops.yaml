version: '3'

# ===============================
# ArgoCD GitOps Platform
# ===============================

vars:
  # Standardized parameters
  CLUSTER_NAME: '{{.CLUSTER_NAME | default "idp-cluster"}}'
  PROVIDER: '{{.PROVIDER | default "kind"}}'
  ENVIRONMENT: '{{.ENVIRONMENT | default "dev"}}'
  NAMESPACE: '{{.NAMESPACE | default "argocd"}}'
  
  # ArgoCD specific configuration
  ARGOCD_VERSION: '{{.ARGOCD_VERSION | default "stable"}}'
  ARGOCD_DOMAIN: '{{.ARGOCD_DOMAIN | default "argocd.local"}}'
  ADMIN_PASSWORD: '{{.ADMIN_PASSWORD | default "admin123"}}'
  
tasks:

  # ===============================
  # ArgoCD Installation
  # ===============================

  install-argocd:
    desc: Install and configure ArgoCD GitOps platform
    vars:
      VERSION: '{{.ARGOCD_VERSION}}'
      NAMESPACE: '{{.NAMESPACE}}'
      ENABLE_INGRESS: '{{.ENABLE_INGRESS | default "true"}}'
    cmds:
      - echo "üöÄ Installing ArgoCD GitOps platform for {{.PROVIDER}} cluster {{.CLUSTER_NAME}}"
      - task: _validate-installation
      - task: _install-argocd-core
      - task: _configure-argocd
      - task: _setup-ingress
        vars:
          ENABLE_INGRESS: '{{.ENABLE_INGRESS}}'
      - task: _verify-installation
      - echo "‚úÖ ArgoCD installation complete"

  uninstall-argocd:
    desc: Uninstall ArgoCD GitOps platform
    vars:
      NAMESPACE: '{{.NAMESPACE}}'
    cmds:
      - echo "üóëÔ∏è Uninstalling ArgoCD from namespace {{.NAMESPACE}}"
      - task: _confirm-uninstall
      - kubectl delete namespace {{.NAMESPACE}} --ignore-not-found=true
      - echo "‚úÖ ArgoCD uninstalled successfully"

  get-admin-password:
    desc: Get ArgoCD admin password
    vars:
      NAMESPACE: '{{.NAMESPACE}}'
    cmds:
      - echo "üîë ArgoCD Admin Password"
      - |
        if kubectl get secret argocd-initial-admin-secret -n {{.NAMESPACE}} >/dev/null 2>&1; then
          kubectl get secret argocd-initial-admin-secret -n {{.NAMESPACE}} -o jsonpath="{.data.password}" | base64 -d
          echo ""
        else
          echo "‚ùå ArgoCD admin secret not found"
        fi

  access-ui:
    desc: Access ArgoCD UI (port-forward)
    vars:
      NAMESPACE: '{{.NAMESPACE}}'
      PORT: '{{.PORT | default "8080"}}'
    cmds:
      - echo "üåê Starting ArgoCD UI port-forward to localhost {{.PORT}}"
      - echo "Username admin"
      - task: get-admin-password
      - kubectl port-forward svc/argocd-server -n {{.NAMESPACE}} {{.PORT}}:443

  # ===============================
  # Application Management
  # ===============================

  list-applications:
    desc: List all ArgoCD applications
    vars:
      NAMESPACE: '{{.NAMESPACE}}'
      OUTPUT: '{{.OUTPUT | default "wide"}}'
    cmds:
      - echo "üì± ArgoCD Applications in {{.NAMESPACE}}"
      - |
        if kubectl get applications -n {{.NAMESPACE}} >/dev/null 2>&1; then
          kubectl get applications -n {{.NAMESPACE}} -o {{.OUTPUT}}
        else
          echo "‚ÑπÔ∏è No ArgoCD applications found"
        fi

  sync-application:
    desc: Sync specific ArgoCD application
    vars:
      APP_NAME: '{{.APP_NAME}}'
      NAMESPACE: '{{.NAMESPACE}}'
    cmds:
      - echo "üîÑ Syncing ArgoCD application {{.APP_NAME}}"
      - |
        if command -v argocd >/dev/null 2>&1; then
          argocd app sync {{.APP_NAME}} --grpc-web
        else
          kubectl patch app {{.APP_NAME}} -n {{.NAMESPACE}} --type merge --patch='{"operation":{"sync":{"revision":"HEAD"}}}'
        fi

  create-application:
    desc: Create new ArgoCD application
    vars:
      APP_NAME: '{{.APP_NAME}}'
      REPO_URL: '{{.REPO_URL}}'
      PATH: '{{.PATH | default "."}}'
      TARGET_NAMESPACE: '{{.TARGET_NAMESPACE | default "default"}}'
      NAMESPACE: '{{.NAMESPACE}}'
    cmds:
      - echo "üì± Creating ArgoCD application {{.APP_NAME}}"
      - |
        cat << EOF | kubectl apply -f -
        apiVersion: argoproj.io/v1alpha1
        kind: Application
        metadata:
          name: {{.APP_NAME}}
          namespace: {{.NAMESPACE}}
        spec:
          destination:
            namespace: {{.TARGET_NAMESPACE}}
            server: https://kubernetes.default.svc
          project: default
          source:
            path: {{.PATH}}
            repoURL: {{.REPO_URL}}
            targetRevision: HEAD
          syncPolicy:
            automated:
              prune: true
              selfHeal: true
        EOF

  # ===============================
  # Status and Health Checks
  # ===============================

  status:
    desc: Show ArgoCD status and health
    vars:
      NAMESPACE: '{{.NAMESPACE}}'
    cmds:
      - echo "üìä ArgoCD Status in {{.NAMESPACE}}"
      - echo "=================================="
      - echo ""
      - echo "üèÉ Pods Status"
      - kubectl get pods -n {{.NAMESPACE}} -o wide
      - echo ""
      - echo "üåê Services Status"  
      - kubectl get svc -n {{.NAMESPACE}}
      - echo ""
      - echo "üì± Applications Summary"
      - task: list-applications
        vars:
          OUTPUT: "custom-columns=NAME:.metadata.name,HEALTH:.status.health.status,SYNC:.status.sync.status,REVISION:.status.sync.revision"

  health-check:
    desc: Comprehensive ArgoCD health check
    vars:
      NAMESPACE: '{{.NAMESPACE}}'
    cmds:
      - echo "üè• ArgoCD Health Check"
      - echo "====================="
      - echo ""
      - |
        # Check namespace
        if kubectl get namespace {{.NAMESPACE}} >/dev/null 2>&1; then
          echo "‚úÖ Namespace {{.NAMESPACE}} exists"
        else
          echo "‚ùå Namespace {{.NAMESPACE}} not found"
          exit 1
        fi
        
        # Check core components
        COMPONENTS=("argocd-server" "argocd-repo-server" "argocd-application-controller")
        for component in "${COMPONENTS[@]}"; do
          if kubectl get deployment $component -n {{.NAMESPACE}} >/dev/null 2>&1; then
            READY=$(kubectl get deployment $component -n {{.NAMESPACE}} -o jsonpath='{.status.readyReplicas}')
            DESIRED=$(kubectl get deployment $component -n {{.NAMESPACE}} -o jsonpath='{.spec.replicas}')
            if [ "$READY" = "$DESIRED" ]; then
              echo "‚úÖ $component ($READY/$DESIRED ready)"
            else
              echo "‚ùå $component ($READY/$DESIRED ready)"
            fi
          else
            echo "‚ùå $component not found"
          fi
        done

  # ===============================
  # Internal Helper Tasks
  # ===============================

  _validate-installation:
    internal: true
    cmds:
      - echo "üîç Validating ArgoCD installation prerequisites"
      - |
        # Check if kubectl is available
        if ! command -v kubectl >/dev/null 2>&1; then
          echo "‚ùå kubectl is required but not installed"
          exit 1
        fi
        
        # Check cluster connectivity
        if ! kubectl cluster-info >/dev/null 2>&1; then
          echo "‚ùå Cannot connect to Kubernetes cluster"
          exit 1
        fi
        
        echo "‚úÖ Prerequisites validated"

  _install-argocd-core:
    internal: true
    vars:
      NAMESPACE: '{{.NAMESPACE}}'
      VERSION: '{{.ARGOCD_VERSION}}'
    cmds:
      - echo "‚öôÔ∏è Installing ArgoCD core components"
      - |
        # Create namespace
        kubectl create namespace {{.NAMESPACE}} --dry-run=client -o yaml | kubectl apply -f -
        
        # Install ArgoCD
        if [ "{{.VERSION}}" = "stable" ]; then
          kubectl apply -n {{.NAMESPACE}} -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
        else
          kubectl apply -n {{.NAMESPACE}} -f https://raw.githubusercontent.com/argoproj/argo-cd/{{.VERSION}}/manifests/install.yaml
        fi
        
        # Wait for ArgoCD to be ready
        kubectl wait --for=condition=available --timeout=600s deployment/argocd-server -n {{.NAMESPACE}}

  _configure-argocd:
    internal: true
    vars:
      NAMESPACE: '{{.NAMESPACE}}'
    cmds:
      - echo "‚öôÔ∏è Configuring ArgoCD"
      - |
        # Configure ArgoCD server for insecure mode (useful for port-forwarding)
        kubectl patch configmap argocd-cmd-params-cm -n {{.NAMESPACE}} --type merge --patch='{"data":{"server.insecure":"true"}}'
        
        # Restart server to apply changes
        kubectl rollout restart deployment/argocd-server -n {{.NAMESPACE}}

  _setup-ingress:
    internal: true
    vars:
      ENABLE_INGRESS: '{{.ENABLE_INGRESS}}'
      NAMESPACE: '{{.NAMESPACE}}'
      DOMAIN: '{{.ARGOCD_DOMAIN}}'
    cmds:
      - |
        if [ "{{.ENABLE_INGRESS}}" = "true" ]; then
          echo "üåê Setting up ArgoCD ingress"
          cat << EOF | kubectl apply -f -
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: argocd-server-ingress
            namespace: {{.NAMESPACE}}
            annotations:
              nginx.ingress.kubernetes.io/ssl-redirect: "false"
              nginx.ingress.kubernetes.io/force-ssl-redirect: "false"
              nginx.ingress.kubernetes.io/backend-protocol: "HTTP"
          spec:
            ingressClassName: nginx
            rules:
            - host: {{.DOMAIN}}
              http:
                paths:
                - path: /
                  pathType: Prefix
                  backend:
                    service:
                      name: argocd-server
                      port:
                        number: 80
        EOF
        else
          echo "‚è≠Ô∏è Skipping ingress setup"
        fi

  _verify-installation:
    internal: true
    vars:
      NAMESPACE: '{{.NAMESPACE}}'
    cmds:
      - echo "‚úÖ Verifying ArgoCD installation"
      - |
        # Wait for all components to be ready
        kubectl wait --for=condition=ready pod -l app.kubernetes.io/part-of=argocd -n {{.NAMESPACE}} --timeout=300s
        echo "‚úÖ All ArgoCD components are ready"

  _confirm-uninstall:
    internal: true
    vars:
      NAMESPACE: '{{.NAMESPACE}}'
    cmds:
      - |
        echo "‚ö†Ô∏è WARNING This will delete all ArgoCD resources in namespace {{.NAMESPACE}}"
        echo "This action cannot be undone."
        echo ""
        read -p "Are you sure you want to continue? (y/N) " -n 1 -r
        echo ""
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
          echo "‚ùå Operation cancelled"
          exit 1
        fi
